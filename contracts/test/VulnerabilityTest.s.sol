
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";

interface ITreasury {
    function emergencyWithdraw(uint256 epochId, uint256 amount) external;
    function forceRollover(uint256 expiredEpochId, uint256 targetEpochId) external;
    function pause() external;
    function unpause() external;
    function currentEpoch() external view returns (uint256);
    function getEpochInfo(uint256 epochId) external view returns (uint256, uint256, uint256, uint256, bool, bool, bool, bool);
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract VulnerabilityTest is Script {
    ITreasury treasury = ITreasury(0x9d5187BC1B838Eb8C80d482247B44e410200B8bA);
    IERC20 pengu = IERC20(0x872309559f33bdb8785A69eaFf51BBD7430b3049);
    
    function run() external {
        vm.startBroadcast();
        
        console.log("=== TESTING ADMIN VULNERABILITIES ===");
        
        uint256 currentEp = treasury.currentEpoch();
        console.log("Current epoch:", currentEp);
        
        // Тест 1: Проверяем emergencyWithdraw защиты
        console.log("\n1. Testing emergency withdraw protections...");
        if (currentEp >= 3) {
            try treasury.emergencyWithdraw(currentEp - 2, 1000000000000000000) {
                console.log("ERROR: Emergency withdraw from recent epoch succeeded!");
            } catch {
                console.log("SUCCESS: Emergency withdraw from recent epoch blocked");
            }
        }
        
        // Тест 2: Проверяем force rollover
        console.log("\n2. Testing force rollover...");
        if (currentEp >= 4) {
            uint256 oldEpoch = currentEp - 3;
            (, , uint256 totalDiv, uint256 claimed, , bool claimable, bool rolloverProc, ) = 
            treasury.getEpochInfo(oldEpoch);
            
            console.log("Old epoch info:");
            console.log("  Total dividends:", totalDiv);
            console.log("  Claimed:", claimed);
            console.log("  Is claimable:", claimable);
            console.log("  Rollover processed:", rolloverProc);
            
            if (!claimable && !rolloverProc && totalDiv > claimed) {
                console.log("Attempting force rollover from epoch", oldEpoch, "to epoch", currentEp);
                
                try treasury.forceRollover(oldEpoch, currentEp) {
                    console.log("SUCCESS: Force rollover executed");
                    
                    // Проверяем результат
                    (, , uint256 newTotal, , , , bool newRolloverProc, ) = 
                    treasury.getEpochInfo(oldEpoch);
                    
                    (, , uint256 targetTotal, , , , , ) = 
                    treasury.getEpochInfo(currentEp);
                    
                    console.log("After rollover:");
                    console.log("  Old epoch rollover processed:", newRolloverProc);
                    console.log("  Target epoch total dividends:", targetTotal);
                } catch {
                    console.log("INFO: Force rollover conditions not met");
                }
            } else {
                console.log("INFO: No valid epochs for force rollover test");
            }
        }
        
        // Тест 3: Pause/Unpause
        console.log("\n3. Testing pause functionality...");
        try treasury.pause() {
            console.log("Contract paused successfully");
            try treasury.unpause() {
                console.log("Contract unpaused successfully");
            } catch {
                console.log("ERROR: Failed to unpause");
            }
        } catch {
            console.log("INFO: Pause function access restricted (good)");
        }
        
        console.log("\nFinal contract balance:", pengu.balanceOf(address(treasury)));
        
        vm.stopBroadcast();
    }
}
